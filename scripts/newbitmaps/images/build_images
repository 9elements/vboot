#!/bin/sh
# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Prepares image resources into output folder.

# Composition settings
BACKGROUND_COLOR=white

# The only file that uses different scaling parameter.
BACKGROUND_IMAGE=Background_white.bmp

# Currently we use image resources originally designed for 1366x768, and
# re-scale to different aspects on demand.
SCALE_16x9_800x600="59%x78%"
SCALE_16x9_1024x768="75%x100%"
SCALE_16x9_1280x1024="94%%x133%"

IMAGE_SCALING="$SCALE_16x9_1280x1024"
BACKGROUND_SIZE="1280x1024"

die() {
  echo "ERROR: $*" >&2
  exit 1
}

convert_to_bmp3() {
  local input="$1"
  local folder="$2"
  local param="$3"
  local output="$(basename "$input")"

  # Always output as .bmp
  output="${output%.*}.bmp"
  mkdir -p "$folder"

  # When input has Alpha channel, we need to fill the background properly
  # otherwise ImageMagick will fill it with black.  The operation (-flatten) is
  # so slow so we only want to do that if the input source really has
  # transparency.
  if [ "$#" -gt 3 ]; then
    flatten="$4"
  else
    # Auto-detect
    if [ "$(identify -format "%A" "$input")" = "True" ]; then
      flatten="-background $BACKGROUND_COLOR -flatten"
    else
      flatten=""
    fi
  fi

  echo "$input -> $folder/$output $flatten"
  convert "$input" $flatten \
    -compress none -alpha off -colors 256 \
    $param "BMP3:$folder/$output"

  # ImageMagic quantization may choose arbitrary color depth, even if we assign
  # -depth or -colors; so a single-color background may become 1 bit per pixel
  # after convertion. To workaround that, we use Python Image Library which
  # always generates 8bpp BMP file.
  # TODO(hungte) Find a better way to decide if PIL is required. Unfortunately,
  # ImageMagic identify "%z" is not always what we're looking for...
  local fn="$folder/$output"
  local param="'P', dither=None, palette=Image.ADAPTIVE"
  python -c "import Image; Image.open('$fn').convert($param).save('$fn')"
}

main() {
  local profile="$1"
  local output="out_$1"
  local scale_param="" background_scale_param=""
  local base locale X

  case "$profile" in
    x86 )
      scale_param="-scale $IMAGE_SCALING"
      background_scale_param="-scale ${BACKGROUND_SIZE}!"
      ;;
    arm )
      # On ARM platforms, we need to provide a bitmap with full size.
      # TODO(hungte) Support more profiles, ex 1280x800.
      true
      ;;
    * )
      die "Sorry, unknown profile $profile."
  esac

  # Prepare output folder
  mkdir -p "$output"

  # Prepare images in current folder
  # TODO(hungte) Deprecate arrow*.bmp by markup &#x25c0; and &#x25b6;, and
  # Url.bmp by <span foreground="blue">http://</span>.
  for X in $(ls *.bmp *.png); do
    if [ "$X" = "$BACKGROUND_IMAGE" ]; then
      convert_to_bmp3 "$X" "$output" "$background_scale_param"
    else
      convert_to_bmp3 "$X" "$output" "$scale_param"
    fi
  done

  # Prepares strings and localized images. All these images were rendered by
  # pango-view and should not have transparency, so we specify flatten="" to
  # speed up.
  echo "Preparing common strings..."
  base="../strings"
  for X in $base/*.png; do
    convert_to_bmp3 "$X" "$output" "$scale_param" ""
  done
  echo "Preparing localized messages... $LOCALES"
  base="../strings/localized_text"
  if [ -z "$LOCALES" ]; then
    # Collect all locales
    for X in $(cd $base; ls); do
      if [ -d "$base/$X" ]; then
        LOCALES="${LOCALES}${X} "
      fi
    done
    echo "Found locales: $LOCALES"
  fi
  for locale in $LOCALES; do
    # Prepare all locales.
    for X in $base/$locale/*.png; do
      convert_to_bmp3 "$X" "$output/locale/$locale" "$scale_param" ""
    done
  done

  # Prepare fonts
  base="../strings/font"
  for X in $base/*.png; do
    convert_to_bmp3 "$X" "$output/font" "$scale_param" ""
  done
  bmpblk_font --outfile "$output/hwid_fonts.bin" "$output"/font/*.bmp
}

set -e
main "$@"

